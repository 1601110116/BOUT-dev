#!/usr/bin/env python3

from __future__ import print_function

try:
    from builtins import object
except ImportError:
    pass

from copy import deepcopy as copy
import itertools


# The arthimetic operators
operators = {
    '*': 'mul',
    '/': 'div',
    '+': 'plus',
    '-': 'minus',
}

header = """// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
"""

for_loop_statement_template = (
    "  for (int {index}=0; {index} < {dimension}; ++{index})\n")

non_compound_template = """
// Do the actual {operator_name} of {lhs_type} and {rhs_type}
void autogen_{out_type}_{lhs_type}_{rhs_type}_{operator_name}(
    {non_compound_low_level_result_arg}, {non_compound_low_level_lhs_arg},
    {non_compound_low_level_rhs_arg}, {non_compound_low_level_length_arg}) {{
  {for_loop} {{
    {result_op} = {lhs_op} {operator} {rhs_op};
  }}
}}

// Provide the C++ wrapper for {operator_name} of {lhs_type} and {rhs_type}
{out_type} operator{operator}({lhs_arg}, {rhs_arg}) {{
  Indices i{{0, 0, 0}};
  Mesh *localmesh = {lhs_or_rhs}.getMesh();
  {mesh_equality_assert}
  {out_type} result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);
  autogen_{out_type}_{lhs_type}_{rhs_type}_{operator_name}(
      {out_low_level_arg}, {lhs_low_level_arg}, {rhs_low_level_arg}, {length_arg});
  {location_check}
  {location_set}
  checkData(result);
  return result;
}}
"""

location_check_template = """#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {{
    throw BoutException(
        "Trying to {operator_name} fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }}
#endif"""
location_set_template = "result.setLocation({lhs_or_rhs}.getLocation());"

compound_template = """
// Provide the C function to update {lhs_type} by {operator_name} with {rhs_type}
void autogen_{lhs_type}_{rhs_type}_{operator_name}(
    {compound_low_level_lhs_arg}, {compound_low_level_rhs_arg}, {compound_low_level_length_arg}) {{
  {for_loop} {{
       {lhs_op} {operator}= {rhs_op};
    }}
}}

// Provide the C++ operator to update {lhs_type} by {operator_name} with {rhs_type}
{lhs_type} &{lhs_type}::operator{operator}=({rhs_arg}) {{
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {{
    Indices i{{0, 0, 0}};
    {mesh_equality_assert}
    checkData(*this);
    checkData(rhs);
    autogen_{lhs_type}_{rhs_type}_{operator_name}(&(*this)[i], {rhs_low_level_arg},
                                  {length_arg});
    {location_check}
  }} else {{
    (*this) = (*this) {operator} rhs;
  }}
  return *this;
}}
"""

compound_location_check_template = """#if CHECK > 0
  if (this->getLocation() != rhs.getLocation()) {{
    throw BoutException("Trying to {operator_name} fields of different locations!");
  }}
#endif
checkData(*this);
"""


class Field(object):
    """A class to keep all the data of the different fields
    """

    def __init__(self, field_type, dimensions):
        # C++ type of the field, e.g. Field3D
        self.field_type = field_type
        # array: dimensions of the field
        self.dimensions = dimensions
        # name of this field
        self.name = None

    def getPass(self, const=True, data=False):
        """How to pass data

        Inputs
        ======
        const: Should it be const?
        data:  Pass the raw data?

        """

        ret = ""
        if const:
            ret += "const "
        if self.field_type == 'BoutReal':
            ret += "BoutReal"
        else:
            if data:
                if for_gcc:  # use restrict gcc extension
                    ret += 'BoutReal * __restrict__'
                else:
                    ret += 'BoutReal *'
            else:
                ret += '%s &' % (self.field_type)
        ret += " %s" % self.name
        return ret

    def get(self, data=True, ptr=False):
        """How to get value from field

        Inputs
        ======
        data: use x,y,z access on raw data?
        ptr:  Do return pointer instead of data

        """

        if self.field_type == 'BoutReal':
            return self.name
        ret = ''
        if ptr:
            ret = "&"
        if data:
            if self.field_type == 'Field2D':
                return ret + '%s[y+x*ny]' % self.name
            elif self.field_type == 'FieldPerp':
                return ret + '%s[z+x*nz]' % self.name
            elif self.field_type == 'Field3D':
                return ret + '%s[z+nz*(y+ny*x)]' % (self.name)
            else:
                raise NotImplementedError
        else:
            return ret + "%s[i]" % self.name

    def __eq__(self, other):
        try:
            return self.field_type == other.field_type
        except AttributeError:
            return self.field_type == other

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        return "Name: %s\nfield_type: %s\n" % (self.name, self.field_type)


# Declare what fields we currently support:
# Field perp is currently missing
field3D = Field('Field3D', ['x', 'y', 'z'])
field2D = Field('Field2D', ['x', 'y'])
boutreal = Field('BoutReal', [])
fields = [field3D, field2D, boutreal]


def returnType(f1, f2):
    """Determine a suitable return type, by seeing which field is 'larger'.

    """
    if f1 == f2:
        return copy(f1)
    elif f1 == 'BoutReal':
        return copy(f2)
    elif f2 == 'BoutReal':
        return copy(f1)
    else:
        return copy(field3D)


def non_compound_function_generator(operator, operator_name, out, lhs, rhs, elementwise):
    """
    It takes the Field objects. This function is doing some high
    level stuff, but does not modify the underlaying data.
    Stuff done here:
     * conserve the mesh
     * conserve the field location
     * check the input & output data
     * allocate data
     * get the underlaying data for the low-level operation

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    # Depending on how we loop over the fields, we need to know
    # x, y and z, or just the total number of elements
    if elementwise:
        non_compound_low_level_length_arg = ",".join(["int n{}".format(d) for d in out.dimensions])
        dims = {"n" + x: x for x in out.dimensions}
    else:
        non_compound_low_level_length_arg = " int len"
        dims = {"len": 'i'}

    for_loop = ""

    # The "for" statements
    for dimension, index in dims.items():
        for_loop += for_loop_statement_template.format(dimension=dimension,
                                                       index=index)

    mesh_equality_assert = ""
    if lhs != 'BoutReal' and rhs != 'BoutReal':
        mesh_equality_assert = "ASSERT1(localmesh == rhs.getMesh());"

    # Either total number of elements, or size of each dimension separately
    m = ',' if elementwise else '*'
    dimension_names = ["localmesh->LocalN{}".format(d) for d in out.dimensions]
    length_arg = m.join(dimension_names)

    # hardcode to only check field location for Field 3D
    location_check = ""
    if lhs == rhs == 'Field3D':
        location_check = location_check_template.format(operator_name=operator_name)

    # Set out location (again, only for field3D)
    location_set = ""
    if out == 'Field3D':
        src = "rhs" if rhs == "Field3D" else "lhs"
        location_set = location_set_template.format(lhs_or_rhs=src)

    lhs_or_rhs = "lhs" if lhs != 'BoutReal' else "rhs"

    template_args = {
        'out_type': out.field_type,
        'lhs_type': lhs.field_type,
        'rhs_type': rhs.field_type,
        'operator': operator,
        'operator_name': operator_name,

        'out_low_level_arg': out.get(data=False, ptr=True),
        'lhs_low_level_arg': lhs.get(data=False, ptr=True),
        'rhs_low_level_arg': rhs.get(data=False, ptr=True),

        'lhs_arg': lhs.getPass(const=True),
        'rhs_arg': rhs.getPass(const=True),
        'length_arg': length_arg,
        'lhs_or_rhs': lhs_or_rhs,
        'location_check': location_check,
        'location_set': location_set,
        'mesh_equality_assert': mesh_equality_assert,

        'non_compound_low_level_result_arg': out.getPass(const=False, data=True),
        'non_compound_low_level_lhs_arg': lhs.getPass(const=True, data=True),
        'non_compound_low_level_rhs_arg': rhs.getPass(const=True, data=True),
        'non_compound_low_level_length_arg': non_compound_low_level_length_arg,

        'length_arg': length_arg,
        'for_loop': for_loop,
        'result_op': out.get(data=elementwise),
        'lhs_op': lhs.get(data=elementwise),
        'rhs_op': rhs.get(data=elementwise),
    }

    print(non_compound_template.format(**template_args))


def compound_function_generator(operator, operator_name, lhs, rhs, elementwise):
    """
    It takes the Field objects. This function is doing some high
    level stuff, but does not modify the underlaying data.
    Stuff done here:
     * conserve the mesh
     * conserve the field location
     * check the input & output data
     * allocate data
     * get the underlaying data for the low-level operation

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    # Depending on how we loop over the fields, we need to know
    # x, y and z, or just the total number of elements
    if elementwise:
        compound_low_level_length_arg = ",".join(["int n{}".format(d) for d in out.dimensions])
        dims = {"n" + x: x for x in out.dimensions}
    else:
        compound_low_level_length_arg = "int len"
        dims = {"len": 'i'}

    for_loop = ""

    # The "for" statements
    for dimension, index in dims.items():
        for_loop += for_loop_statement_template.format(dimension=dimension,
                                                       index=index)

    mesh_equality_assert = ""
    if lhs != 'BoutReal' and rhs != 'BoutReal':
        mesh_equality_assert = "ASSERT1(fieldmesh == rhs.getMesh());"

    # Either total number of elements, or size of each dimension separately
    m = ',' if elementwise else '*'
    dimension_names = ["fieldmesh->LocalN{}".format(d) for d in out.dimensions]
    length_arg = m.join(dimension_names)

    # hardcode to only check field location for Field 3D
    location_check = ""
    if lhs == rhs == 'Field3D':
        location_check = compound_location_check_template.format(operator_name=operator_name)

    lhs_or_rhs = "lhs" if lhs != 'BoutReal' else "rhs"

    template_args = {
        'out_type': out.field_type,
        'lhs_type': lhs.field_type,
        'rhs_type': rhs.field_type,

        'operator': operator,
        'operator_name': operator_name,

        'compound_low_level_length_arg': compound_low_level_length_arg,
        'length_arg': length_arg,
        'for_loop': for_loop,

        'compound_low_level_lhs_arg': lhs.getPass(const=False, data=True),
        'compound_low_level_rhs_arg': rhs.getPass(const=True, data=True),
        'out_low_level_arg': out.get(data=False, ptr=True),
        'lhs_low_level_arg': lhs.get(data=False, ptr=True),
        'rhs_low_level_arg': rhs.get(data=False, ptr=True),

        'lhs_arg': lhs.getPass(const=True),
        'rhs_arg': rhs.getPass(const=True),

        'lhs_or_rhs': lhs_or_rhs,
        'location_check': location_check,
        'mesh_equality_assert': mesh_equality_assert,

        'lhs_op': lhs.get(data=elementwise),
        'rhs_op': rhs.get(data=elementwise),
    }

    print(compound_template.format(**template_args))


if __name__ == "__main__":
    for_gcc = True
    print(header)

    for lhs, rhs in itertools.product(fields, fields):
        # We don't have define real real operations
        if lhs == rhs == 'BoutReal':
            continue
        rhs = copy(rhs)
        lhs = copy(lhs)

        # If both fields are the same, or one of them is real, we
        # don't need to care what element is stored where, but can
        # just loop directly over everything, using a simple c-style
        # for loop. Otherwise we need x,y,z of the fields.
        elementwise = lhs != rhs and lhs != 'BoutReal' and rhs != 'BoutReal'

        # The output of the operation. The `larger` of the two fields.
        out = returnType(rhs, lhs)
        out.name = 'result'
        lhs.name = 'lhs'
        rhs.name = 'rhs'

        for operator, operator_name in operators.items():
            non_compound_function_generator(operator, operator_name, out, lhs, rhs, elementwise)

            if out == lhs:
                compound_function_generator(operator, operator_name, lhs, rhs, elementwise)
