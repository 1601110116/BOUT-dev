#!/usr/bin/env python3

from __future__ import print_function

try:
    from builtins import object
except ImportError:
    pass

from copy import deepcopy as copy
import itertools


# The arthimetic operators
operators = {
    '*': 'mul',
    '/': 'div',
    '+': 'plus',
    '-': 'minus',
}

header = """// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
"""

low_level_function_template = """
// Do the actual {operator_name} of {lhs_type} and {rhs_type}
void autogen_{out_type}_{lhs_type}_{rhs_type}_{operator_name}(
    {result_arg}, {lhs_arg}, {rhs_arg}, {length_arg}) {{
  {for_loop}
}}

"""

for_loop_statement_template = (
    "  for (int {index}=0; {index} < {dimension}; ++{index})\n")
operator_body_template = "{{\n    {result} = {lhs} {operator} {rhs};}}"
compound_assignment_template = "{{\n    {lhs} {operator}= {rhs};}}"

non_compound_high_level_template = """
// Provide the C++ wrapper for {operator_name} of {lhs_type} and {rhs_type}
{out_type} operator{operator}({lhs_arg}, {rhs_arg}) {{
  Indices i{{0, 0, 0}};
  Mesh *localmesh = {lhs_or_rhs}.getMesh();
  {mesh_equality_assert}
  {out_type} result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);
  autogen_{out_type}_{lhs_type}_{rhs_type}_{operator_name}(
      {out_low_level_arg}, {lhs_low_level_arg}, {rhs_low_level_arg}, {length_arg});
  {location_check}
  {location_set}
  checkData(result);
  return result;
}}
"""

location_check_template = """#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {{
    throw BoutException(
        "Trying to {operator_name} fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }}
#endif"""
compound_location_check_template = """#if CHECK > 0
  if (this->getLocation() != rhs.getLocation()) {{
    throw BoutException("Trying to {operator_name} fields of different locations!");
  }}
#endif"""
location_set_template = "result.setLocation({lhs_or_rhs}.getLocation());"

low_level_compound_template = """
// Provide the C function to update {lhs_type} by {operator_name} with {rhs_type}
void autogen_{lhs_type}_{rhs_type}_{operator_name}(
    {lhs_arg}, {rhs_arg}, {length_arg}) {{
  {for_loop}
}}

"""

compound_high_level_template = """
// Provide the C++ operator to update {lhs_type} by {operator_name} with {rhs_type}
{lhs_type} &{lhs_type}::operator{operator}=({rhs_arg}) {{
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {{
    Indices i{{0, 0, 0}};
    {mesh_equality_assert}
    checkData(*this);
    checkData(rhs);
    autogen_{lhs_type}_{rhs_type}_{operator_name}(&(*this)[i], {rhs_low_level_arg},
                                  {length_arg});
    {location_check}
    {optional_checkData}
  }} else {{
    (*this) = (*this) {operator} rhs;
  }}
  return *this;
}}
"""


class Field(object):
    """A class to keep all the data of the different fields
    """

    def __init__(self, name, dimensions, field_type):
        # name of the field, e.g. Field3D
        self.fieldname = name
        # array: dimensions of the field
        self.dimensions = dimensions
        # identifier - short version of the field e.g. f3d
        self.field_type = field_type
        # name of this field
        self.name = None

    def getPass(self, const=True, data=False):
        """How to pass data

        Inputs
        ======
        const: Should it be const?
        data:  Pass the raw data?

        """

        ret = ""
        if const:
            ret += "const "
        if self.field_type == 'real':
            ret += "BoutReal"
        else:
            if data:
                if for_gcc:  # use restrict gcc extension
                    ret += 'BoutReal * __restrict__'
                else:
                    ret += 'BoutReal *'
            else:
                ret += '%s &' % (self.fieldname)
        ret += " %s" % self.name
        return ret

    def get(self, data=True, ptr=False):
        """How to get value from field

        Inputs
        ======
        data: use x,y,z access on raw data?
        ptr:  Do return pointer instead of data

        """

        if self.field_type == 'real':
            return self.name
        ret = ''
        if ptr:
            ret = "&"
        if data:
            if self.field_type == 'f2d':
                return ret + '%s[y+x*ny]' % self.name
            elif self.field_type == 'fp':
                return ret + '%s[z+x*nz]' % self.name
            elif self.field_type == 'f3d':
                return ret + '%s[z+nz*(y+ny*x)]' % (self.name)
            else:
                raise NotImplementedError
        else:
            return ret + "%s[i]" % self.name

    def __eq__(self, other):
        try:
            return self.field_type == other.field_type
        except AttributeError:
            return self.field_type == other

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        return "Name: %s\nfieldname: %s\n" % (self.name, self.fieldname)


# Declare what fields we currently support:
# Field perp is currently missing
f3d = Field('Field3D', ['x', 'y', 'z'], 'f3d')
f2d = Field('Field2D', ['x', 'y'], 'f2d')
real = Field('BoutReal', [], 'real')
fields = [f3d, f2d, real]


def returnType(f1, f2):
    """Determine a suitable return type, by seeing which field is 'larger'.

    """
    if f1 == f2:
        return copy(f1)
    elif f1 == 'real':
        return copy(f2)
    elif f2 == 'real':
        return copy(f1)
    else:
        return copy(f3d)


def non_compound_low_level_function_generator(operator, operator_name, out,
                                              lhs, rhs, elementwise):
    """Generate the function that operates on the underlying data

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    # Depending on how we loop over the fields, we need to know
    # x, y and z, or just the total number of elements
    if elementwise:
        length_arg = ",".join(["int n{}".format(d) for d in out.dimensions])
        dims = {"n" + x: x for x in out.dimensions}
    else:
        length_arg = " int len"
        dims = {"len": 'i'}

    for_loop = ""

    # The "for" statements
    for dimension, index in dims.items():
        for_loop += for_loop_statement_template.format(dimension=dimension,
                                                       index=index)

    # The loop body
    for_loop += operator_body_template.format(result=out.get(data=elementwise),
                                              lhs=lhs.get(data=elementwise),
                                              operator=operator,
                                              rhs=rhs.get(data=elementwise))

    stuff = {'out_type': out.fieldname,
             'lhs_type': lhs.fieldname,
             'rhs_type': rhs.fieldname,
             'operator_name': operator_name,
             'result_arg': out.getPass(const=False, data=True),
             'lhs_arg': lhs.getPass(const=True, data=True),
             'rhs_arg': rhs.getPass(const=True, data=True),
             'length_arg': length_arg,
             'for_loop': for_loop,
             }

    print(low_level_function_template.format(**stuff))


def non_compound_high_level_function_generator(operator, operator_name, out,
                                               lhs, rhs, elementwise):
    """
    It takes the Field objects. This function is doing some high
    level stuff, but does not modify the underlaying data.
    Stuff done here:
     * conserve the mesh
     * conserve the field location
     * check the input & output data
     * allocate data
     * get the underlaying data for the low-level operation

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    if lhs != 'real' and rhs != 'real':
        mesh_equality_assert = "ASSERT1(localmesh == rhs.getMesh());"
    else:
        mesh_equality_assert = ""

    # Either total number of elements, or size of each dimension separately
    m = ',' if elementwise else '*'
    dimension_names = ["localmesh->LocalN{}".format(d) for d in out.dimensions]
    length_arg = m.join(dimension_names)

    # hardcode to only check field location for Field 3D
    if lhs == rhs == 'f3d':
        location_check = location_check_template.format(operator_name=operator_name)
    else:
        location_check = ""

    # Set out location (again, only for f3d)
    if out == 'f3d':
        if rhs == 'f3d':
            src = 'rhs'
        elif lhs != 'real':
            src = 'lhs'
        else:
            src = 'rhs'
        location_set = location_set_template.format(lhs_or_rhs=src)
    else:
        location_set = ""

    lhs_or_rhs = "lhs" if lhs != 'real' else "rhs"

    stuff = {'out_type': out.fieldname,
             'lhs_type': lhs.fieldname,
             'rhs_type': rhs.fieldname,
             'operator': operator,
             'operator_name': operator_name,
             'out_low_level_arg': out.get(data=False, ptr=True),
             'lhs_low_level_arg': lhs.get(data=False, ptr=True),
             'rhs_low_level_arg': rhs.get(data=False, ptr=True),
             'length_arg': length_arg,
             'lhs_arg': lhs.getPass(const=True),
             'rhs_arg': rhs.getPass(const=True),
             'length_arg': length_arg,
             'lhs_or_rhs': lhs_or_rhs,
             'location_check': location_check,
             'location_set': location_set,
             'mesh_equality_assert': mesh_equality_assert,
             }

    print(non_compound_high_level_template.format(**stuff))


def compound_low_level_function_generator(operator, operator_name, lhs, rhs, elementwise):
    """
    This function operates on the underlying data

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    # Depending on how we loop over the fields, we need to know
    # x, y and z, or just the total number of elements
    if elementwise:
        length_arg = ",".join(["int n{}".format(d) for d in out.dimensions])
        dims = {"n" + x: x for x in out.dimensions}
    else:
        length_arg = " int len"
        dims = {"len": 'i'}

    for_loop = ""

    # The "for" statements
    for dimension, index in dims.items():
        for_loop += for_loop_statement_template.format(dimension=dimension,
                                                       index=index)

    # The loop body
    for_loop += compound_assignment_template.format(lhs=lhs.get(data=elementwise),
                                                    operator=operator,
                                                    rhs=rhs.get(data=elementwise))

    stuff = {'out_type': out.fieldname,
             'lhs_type': lhs.fieldname,
             'rhs_type': rhs.fieldname,
             'operator_name': operator_name,
             'lhs_arg': lhs.getPass(const=False, data=True),
             'rhs_arg': rhs.getPass(const=True, data=True),
             'length_arg': length_arg,
             'for_loop': for_loop,
             }

    print(low_level_compound_template.format(**stuff))


def compound_high_level_function_generator(operator, operator_name, lhs, rhs, elementwise):
    """
    It takes the Field objects. This function is doing some high
    level stuff, but does not modify the underlaying data.
    Stuff done here:
     * conserve the mesh
     * conserve the field location
     * check the input & output data
     * allocate data
     * get the underlaying data for the low-level operation

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    if lhs != 'real' and rhs != 'real':
        mesh_equality_assert = "ASSERT1(fieldmesh == rhs.getMesh());"
    else:
        mesh_equality_assert = ""

    # Either total number of elements, or size of each dimension separately
    m = ',' if elementwise else '*'
    dimension_names = ["fieldmesh->LocalN{}".format(d) for d in out.dimensions]
    length_arg = m.join(dimension_names)

    # hardcode to only check field location for Field 3D
    if lhs == rhs == 'f3d':
        location_check = compound_location_check_template.format(operator_name=operator_name)
        optional_checkData = "checkData(*this);"
    else:
        location_check = ""
        optional_checkData = ""

    lhs_or_rhs = "lhs" if lhs != 'real' else "rhs"

    stuff = {'out_type': out.fieldname,
             'lhs_type': lhs.fieldname,
             'rhs_type': rhs.fieldname,
             'operator': operator,
             'operator_name': operator_name,
             'out_low_level_arg': out.get(data=False, ptr=True),
             'lhs_low_level_arg': lhs.get(data=False, ptr=True),
             'rhs_low_level_arg': rhs.get(data=False, ptr=True),
             'length_arg': length_arg,
             'lhs_arg': lhs.getPass(const=True),
             'rhs_arg': rhs.getPass(const=True),
             'length_arg': length_arg,
             'lhs_or_rhs': lhs_or_rhs,
             'location_check': location_check,
             'optional_checkData': optional_checkData,
             'mesh_equality_assert': mesh_equality_assert,
             }

    print(compound_high_level_template.format(**stuff))


if __name__ == "__main__":
    for_gcc = True
    print(header)

    for lhs, rhs in itertools.product(fields, fields):
        # We don't have define real real operations
        if lhs == rhs == 'real':
            continue
        rhs = copy(rhs)
        lhs = copy(lhs)

        # If both fields are the same, or one of them is real, we
        # don't need to care what element is stored where, but can
        # just loop directly over everything, using a simple c-style
        # for loop. Otherwise we need x,y,z of the fields.
        elementwise = lhs != rhs and lhs != 'real' and rhs != 'real'

        # The output of the operation. The `larger` of the two fields.
        out = returnType(rhs, lhs)
        out.name = 'result'
        lhs.name = 'lhs'
        rhs.name = 'rhs'

        for operator, operator_name in operators.items():
            non_compound_low_level_function_generator(operator, operator_name, out, lhs, rhs,
                                                      elementwise)
            non_compound_high_level_function_generator(operator, operator_name, out, lhs, rhs,
                                                       elementwise)

            if out == lhs:
                compound_low_level_function_generator(operator, operator_name, lhs, rhs,
                                                      elementwise)
                compound_high_level_function_generator(operator, operator_name, lhs, rhs,
                                                       elementwise)
