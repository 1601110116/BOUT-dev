#!/usr/bin/env python3

from __future__ import print_function

try:
    from builtins import object
except ImportError:
    pass

from copy import deepcopy as copy
import itertools


# The arthimetic operators
operators = {
    '*': 'mul',
    '/': 'div',
    '+': 'plus',
    '-': 'minus',
}

header = """// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
"""

low_level_function_template = """
// Do the actual {operator_name} of {lhs_type} and {rhs_type}
void autogen_{out_type}_{lhs_type}_{rhs_type}_{operator_name}(
    {result_arg}, {lhs_arg}, {rhs_arg}, {length_arg}) {{
  {for_loop}
}}

"""

for_loop_statement_template = (
    "  for (int {index}=0; {index} < {dimension}; ++{index})\n")
operator_body_template = "{{\n    {result} = {lhs} {operator} {rhs};}}"
compound_assignment_template = "{{\n    {lhs} {operator}= {rhs};}}"

non_compound_high_level_template = """
// Provide the C++ wrapper for {operator_name} of {lhs_type} and {rhs_type}
{out_type} operator{operator}({lhs_arg}, {rhs_arg}) {{
  Indices i{{0, 0, 0}};
  Mesh *localmesh = {lhs_or_rhs}.getMesh();
  {mesh_equality_assert}
  {out_type} result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);
  autogen_{out_type}_{lhs_type}_{rhs_type}_{operator_name}(
      {out_low_level_arg}, {lhs_low_level_arg}, {rhs_low_level_arg}, {length_arg});
  {location_check}
  {location_set}
  checkData(result);
  return result;
}}
"""

location_check_template = """
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {{
    throw BoutException(
        "Trying to {operator_name} fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }}
#endif
"""
location_set_template = "result.setLocation({lhs_or_rhs}.getLocation());"


class braces(object):
    def __init__(self, string=""):
        print("%s{" % string)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("}")


class Field(object):
    """A class to keep all the data of the different fields
    """
    # name of the field, e.g. Field3D
    fieldname = ''
    # array: dimensions of the field
    dimensions = []
    # identifier - short version of the field e.g. f3d
    i = ''
    # name of this field
    name = None

    def __init__(self, name, dirs, idn):
        self.fieldname = name
        self.dimensions = dirs
        self.i = idn
        self.name = None

    def getPass(self, const=True, data=False):
        """How to pass data

        Inputs
        ======
        const: Should it be const?
        data:  Pass the raw data?

        """

        ret = ""
        if const:
            ret += "const "
        if self.i == 'real':
            ret += "BoutReal"
        else:
            if data:
                if for_gcc:  # use restrict gcc extension
                    ret += 'BoutReal * __restrict__'
                else:
                    ret += 'BoutReal *'
            else:
                ret += '%s &' % (self.fieldname)
        ret += " %s" % self.name
        return ret

    def get(self, data=True, ptr=False):
        """How to get value from field

        Inputs
        ======
        data: use x,y,z access on raw data?
        ptr:  Do return pointer instead of data

        """

        if self.i == 'real':
            return self.name
        ret = ''
        if ptr:
            ret = "&"
        if data:
            if self.i == 'f2d':
                return ret + '%s[y+x*ny]' % self.name
            elif self.i == 'fp':
                return ret + '%s[z+x*nz]' % self.name
            elif self.i == 'f3d':
                return ret + '%s[z+nz*(y+ny*x)]' % (self.name)
            else:
                return NotImplemented
        else:
            return ret + "%s[i]" % self.name

    def dims(self):
        """Return the dimensions
        """
        return self.dimensions

    def __eq__(self, other):
        try:
            return self.i == other.i
        except AttributeError:
            return self.i == other

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        return "Name: %s\nfieldname: %s\n" % (self.name, self.fieldname)

    def setName(self, name):
        self.name = name


# Declare what fields we currently support:
# Field perp is currently missing
f3d = Field('Field3D', ['x', 'y', 'z'], 'f3d')
f2d = Field('Field2D', ['x', 'y'], 'f2d')
real = Field('BoutReal', [], 'real')
fields = [f3d, f2d, real]


def returnType(f1, f2):
    """Determine a suitable return type, by seeing which field is 'larger'.

    """
    if f1 == f2:
        return copy(f1)
    elif f1.i == 'real':
        return copy(f2)
    elif f2.i == 'real':
        return copy(f1)
    else:
        return copy(f3d)


def mymin(f1, f2):
    """Return which of f1, f2 has the least number of dimensions

    """
    if (len(f1.dimensions) < len(f2.dimensions)):
        return f1
    else:
        return f2


def non_compound_low_level_function_generator(operator, operator_name, out,
                                              lhs, rhs, elementwise):
    """Generate the function that operates on the underlying data

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    # Depending on how we loop over the fields, we need to know
    # x, y and z, or just the total number of elements
    if elementwise:
        length_arg = ",".join(["int n{}".format(d) for d in out.dims()])
        dims = {"n" + x: x for x in out.dims()}
    else:
        length_arg = " int len"
        dims = {"len": 'i'}

    for_loop = ""

    # The "for" statements
    for dimension, index in dims.items():
        for_loop += for_loop_statement_template.format(dimension=dimension,
                                                       index=index)

    # The loop body
    for_loop += operator_body_template.format(result=out.get(data=elementwise),
                                              lhs=lhs.get(data=elementwise),
                                              operator=operator,
                                              rhs=rhs.get(data=elementwise))

    stuff = {'out_type': out.fieldname,
             'lhs_type': lhs.fieldname,
             'rhs_type': rhs.fieldname,
             'operator_name': operator_name,
             'result_arg': out.getPass(const=False, data=True),
             'lhs_arg': lhs.getPass(const=True, data=True),
             'rhs_arg': rhs.getPass(const=True, data=True),
             'length_arg': length_arg,
             'for_loop': for_loop,
             }

    print(low_level_function_template.format(**stuff))


def non_compound_high_level_function_generator(operator, operator_name, out,
                                               lhs, rhs, elementwise):
    """
    It takes the Field objects. This function is doing some high
    level stuff, but does not modify the underlaying data.
    Stuff done here:
     * conserve the mesh
     * conserve the field location
     * check the input & output data
     * allocate data
     * get the underlaying data for the low-level operation

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    if lhs.i != 'real' and rhs.i != 'real':
        mesh_equality_assert = "ASSERT1(localmesh == rhs.getMesh());"
    else:
        mesh_equality_assert = ""

    # Either total number of elements, or size of each dimension separately
    m = ',' if elementwise else '*'
    dimension_names = ["localmesh->LocalN{}".format(d) for d in out.dimensions]
    length_arg = m.join(dimension_names)

    # hardcode to only check field location for Field 3D
    if lhs.i == rhs.i == 'f3d':
        location_check = location_check_template.format(operator_name=operator_name)
    else:
        location_check = ""

    # Set out location (again, only for f3d)
    if out.i == 'f3d':
        if rhs.i == 'f3d':
            src = 'rhs'
        elif lhs.i != 'real':
            src = 'lhs'
        else:
            src = 'rhs'
        location_set = location_set_template.format(lhs_or_rhs=src)
    else:
        location_set = ""

    lhs_or_rhs = "lhs" if not lhs.i == 'real' else "rhs"

    stuff = {'out_type': out.fieldname,
             'lhs_type': lhs.fieldname,
             'rhs_type': rhs.fieldname,
             'operator': operator,
             'operator_name': operator_name,
             'out_low_level_arg': out.get(data=False, ptr=True),
             'lhs_low_level_arg': lhs.get(data=False, ptr=True),
             'rhs_low_level_arg': rhs.get(data=False, ptr=True),
             'length_arg': length_arg,
             'lhs_arg': lhs.getPass(const=True),
             'rhs_arg': rhs.getPass(const=True),
             'length_arg': length_arg,
             'lhs_or_rhs': lhs_or_rhs,
             'location_check': location_check,
             'location_set': location_set,
             'mesh_equality_assert': mesh_equality_assert,
             }

    print(non_compound_high_level_template.format(**stuff))


def compound_low_level_function_generator(operator, operator_name, lhs, rhs, elementwise):
    """
    This function operates on the underlying data

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    print("// Provide the C function to update %s by %s with %s" %
          (lhs.fieldname, operator_name, rhs.fieldname))
    print('void autogen_%s_%s_%s(' %
          (lhs.fieldname, rhs.fieldname, operator_name), end=' ')
    const = False
    fs = [lhs, rhs]
    for f in fs:
        print(f.getPass(data=True, const=const), ",", end=' ')
        const = True
    if elementwise:
        c = ''
        for d in out.dimensions:
            print('%s int n%s' % (c, d), end=' ')
            c = ','
    else:
        print(' int len', end=' ')
    print(')')

    with braces():
        if elementwise:
            # we need to loop over all dimension of the out file
            dims = {"n" + x: x for x in out.dims()}
        else:
            dims = {"len": 'i'}
        for d, i in dims.items():
            print('  for (int %s=0;%s<%s;++%s)' % (i, i, d, i))
        with braces():
            print("    %s %s= %s;" % (lhs.get(data=elementwise),
                                      operator,
                                      rhs.get(data=elementwise)))


def compound_high_level_function_generator(operator, operator_name, lhs, rhs, elementwise):
    """
    It takes the Field objects. This function is doing some high
    level stuff, but does not modify the underlaying data.
    Stuff done here:
     * conserve the mesh
     * conserve the field location
     * check the input & output data
     * allocate data
     * get the underlaying data for the low-level operation

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    print("// Provide the C++ operator to update %s by %s with %s" %
          (lhs.fieldname, operator_name, rhs.fieldname))
    print("%s & %s::operator %s=" %
          (lhs.fieldname, lhs.fieldname, operator), end=' ')
    print("(%s)" % (rhs.getPass(const=True)))
    with braces():
        print("  // only if data is unique we update the field")
        print("  // otherwise just call the non-inplace version")
        with braces("  if (data.unique())"):
            print("    Indices i{0,0,0};")
            if not rhs.i == 'real':
                print("    ASSERT1(fieldmesh == rhs.getMesh());")
            print("    checkData(*this);")
            print("    checkData(rhs);")
            print("    autogen_%s_%s_%s(&(*this)[i]," %
                  (lhs.fieldname, rhs.fieldname, operator_name), end=' ')
            print(rhs.get(ptr=True, data=False), ',', end=' ')
            m = ''
            print('\n             ', end=' ')
            for d in out.dimensions:
                print(m, "fieldmesh->LocalN%s" % d, end=' ')
                if elementwise:
                    m = ','
                else:
                    m = '*'
            print(");")
            # if both are f3d, make sure they are in the same location
            if lhs.i == rhs.i == 'f3d':
                print("#if CHECK > 0")
                with braces("  if (this->getLocation() != rhs.getLocation())"):
                    print('    throw BoutException("Trying to %s fields of different locations!");'
                          % operator_name)
                print('#endif')
                print("    checkData(*this);")
        with braces(" else "):  # if data is not unique
            print("    (*this)= (*this) %s rhs;" % operator)
        print("  return *this;")
    print()
    print()


if __name__ == "__main__":
    for_gcc = True
    print(header)

    for lhs, rhs in itertools.product(fields, fields):
        # We don't have define real real operations
        if lhs.i == rhs.i == 'real':
            continue
        rhs = copy(rhs)
        lhs = copy(lhs)

        # If both fields are the same, or one of them is real, we
        # don't need to care what element is stored where, but can
        # just loop directly over everything, using a simple c-style
        # for loop. Otherwise we need x,y,z of the fields.
        elementwise = lhs != rhs and mymin(lhs, rhs).i != 'real'

        # The output of the operation. The `larger` of the two fields.
        out = returnType(rhs, lhs)
        out.name = 'result'
        lhs.name = 'lhs'
        rhs.name = 'rhs'

        for operator, operator_name in operators.items():
            non_compound_low_level_function_generator(operator, operator_name, out, lhs, rhs,
                                                      elementwise)
            non_compound_high_level_function_generator(operator, operator_name, out, lhs, rhs,
                                                       elementwise)

            if out == lhs:
                compound_low_level_function_generator(operator, operator_name, lhs, rhs,
                                                      elementwise)
                compound_high_level_function_generator(operator, operator_name, lhs, rhs,
                                                       elementwise)
