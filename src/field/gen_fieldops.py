#!/usr/bin/env python3

from __future__ import print_function

try:
    from builtins import object
except ImportError:
    pass

from copy import deepcopy as copy
import itertools


# The arthimetic operators
operators = {
    '*': 'mul',
    '/': 'div',
    '+': 'plus',
    '-': 'minus',
}

header = """// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
"""

for_loop_statement_template = (
    "  for (int {index}=0; {index} < {dimension}; ++{index})\n")

non_compound_template = """
// Do the actual {operator_name} of {lhs} and {rhs}
void autogen_{out}_{lhs}_{rhs}_{operator_name}(
    {out.passBoutRealPointer}, const {lhs.passBoutRealPointer},
    const {rhs.passBoutRealPointer}, {low_level_length_arg}) {{
  {for_loop} {{
    {result_op} = {lhs_op} {operator} {rhs_op};
  }}
}}

// Provide the C++ wrapper for {operator_name} of {lhs} and {rhs}
{out} operator{operator}(const {lhs.passByReference}, const {rhs.passByReference}) {{
  Indices i{{0, 0, 0}};
  Mesh *localmesh = {mesh_source}.getMesh();
  {mesh_equality_assert}
  {out} result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);
  autogen_{out}_{lhs}_{rhs}_{operator_name}(
      {out_low_level_arg}, {lhs_low_level_arg}, {rhs_low_level_arg}, {non_compound_length_arg});
  {non_compound_location_check}
  {non_compound_location_set}
  checkData(result);
  return result;
}}
"""

location_check_template = """#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {{
    throw BoutException(
        "Trying to {operator_name} fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }}
#endif"""
location_set_template = "result.setLocation({location_source}.getLocation());"

compound_template = """
// Provide the C function to update {lhs} by {operator_name} with {rhs}
void autogen_{lhs}_{rhs}_{operator_name}(
    {lhs.passBoutRealPointer}, const {rhs.passBoutRealPointer}, {low_level_length_arg}) {{
  {for_loop} {{
       {lhs_op} {operator}= {rhs_op};
    }}
}}

// Provide the C++ operator to update {lhs} by {operator_name} with {rhs}
{lhs} &{lhs}::operator{operator}=(const {rhs.passByReference}) {{
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {{
    Indices i{{0, 0, 0}};
    {compound_mesh_equality_assert}
    checkData(*this);
    checkData(rhs);
    autogen_{lhs}_{rhs}_{operator_name}(&(*this)[i], {rhs_low_level_arg},
                                  {compound_length_arg});
    {compound_location_check}
  }} else {{
    (*this) = (*this) {operator} rhs;
  }}
  return *this;
}}
"""

compound_location_check_template = """#if CHECK > 0
  if (this->getLocation() != rhs.getLocation()) {{
    throw BoutException("Trying to {operator_name} fields of different locations!");
  }}
#endif
checkData(*this);
"""


class Field(object):
    """A class to keep all the data of the different fields
    """

    def __init__(self, field_type, dimensions, name=None):
        # C++ type of the field, e.g. Field3D
        self.field_type = field_type
        # array: dimensions of the field
        self.dimensions = dimensions
        # name of this field
        self.name = name

    @property
    def passByReference(self):
        """Returns "Type& name", except if Type is BoutReal,
        in which case just returns "Type name"

        """
        return "{self.field_type}{ref} {self.name}".format(
            self=self, ref="&" if self.field_type != "BoutReal" else "")

    @property
    def passBoutRealPointer(self):
        """Returns "BoutReal* name", except if field_type is BoutReal,
        in which case just returns "BoutReal name"

        Also adds "__restrict__" attribute if `for_gcc` is True
        """
        return "BoutReal {ref}{restrict} {self.name}".format(
            self=self, ref="*" if self.field_type != "BoutReal" else "",
            restrict="__restrict__" if for_gcc and self.field_type != "BoutReal" else "")

    def get(self, data=True, ptr=False):
        """How to get value from field

        Inputs
        ======
        data: use x,y,z access on raw data?
        ptr:  Do return pointer instead of data

        """

        if self.field_type == 'BoutReal':
            return self.name
        ret = ''
        if ptr:
            ret = "&"
        if data:
            if self.field_type == 'Field2D':
                return ret + '%s[y+x*ny]' % self.name
            elif self.field_type == 'FieldPerp':
                return ret + '%s[z+x*nz]' % self.name
            elif self.field_type == 'Field3D':
                return ret + '%s[z+nz*(y+ny*x)]' % (self.name)
            else:
                raise NotImplementedError
        else:
            return ret + "%s[i]" % self.name

    def __eq__(self, other):
        try:
            return self.field_type == other.field_type
        except AttributeError:
            return self.field_type == other

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "Field({}, {}, {})".format(self.field_type, self.dimensions, self.name)

    def __str__(self):
        return self.field_type


# Declare what fields we currently support:
# Field perp is currently missing
field3D = Field('Field3D', ['x', 'y', 'z'])
field2D = Field('Field2D', ['x', 'y'])
boutreal = Field('BoutReal', [])
fields = [field3D, field2D, boutreal]


def returnType(f1, f2):
    """Determine a suitable return type, by seeing which field is 'larger'.

    """
    if f1 == f2:
        return copy(f1)
    elif f1 == 'BoutReal':
        return copy(f2)
    elif f2 == 'BoutReal':
        return copy(f1)
    else:
        return copy(field3D)


def conext_generator(operator, operator_name, out, lhs, rhs, elementwise):
    """
    Generate the context to be substituted into the templates

    Inputs
    ======
    operator:      String representation of the operator to apply
    operator_name: English name of the operator
    out:           Field for the result
    lhs:           Field for the left-hand side input argument
    rhs:           Field for the right-hand side input argument
    """

    # Depending on how we loop over the fields, we need to know
    # x, y and z, or just the total number of elements
    if elementwise:
        low_level_length_arg = ",".join(["int n{}".format(d) for d in out.dimensions])
        dims = {"n" + x: x for x in out.dimensions}
    else:
        low_level_length_arg = " int len"
        dims = {"len": 'i'}

    for_loop = ""
    for dimension, index in dims.items():
        for_loop += for_loop_statement_template.format(dimension=dimension,
                                                       index=index)

    mesh_equality_assert = ""
    compound_mesh_equality_assert = ""
    if lhs != 'BoutReal' and rhs != 'BoutReal':
        mesh_equality_assert = "ASSERT1(localmesh == rhs.getMesh());"
        compound_mesh_equality_assert = "ASSERT1(fieldmesh == rhs.getMesh());"

    # Either total number of elements, or size of each dimension separately
    m = ',' if elementwise else '*'
    non_compound_length_arg = m.join(["localmesh->LocalN{}".format(d) for d in out.dimensions])
    compound_length_arg = m.join(["fieldmesh->LocalN{}".format(d) for d in out.dimensions])

    # hardcode to only check field location for Field 3D
    non_compound_location_check = ""
    compound_location_check = ""
    if lhs == rhs == 'Field3D':
        non_compound_location_check = location_check_template.format(operator_name=operator_name)
        compound_location_check = compound_location_check_template.format(
            operator_name=operator_name)

    # Set out location (again, only for field3D)
    non_compound_location_set = ""
    if out == 'Field3D':
        source = "rhs" if rhs == "Field3D" else "lhs"
        non_compound_location_set = location_set_template.format(location_source=source)

    mesh_source = "lhs" if lhs != 'BoutReal' else "rhs"

    template_args = {
        'out': out,
        'lhs': lhs,
        'rhs': rhs,

        'operator': operator,
        'operator_name': operator_name,

        'low_level_length_arg': low_level_length_arg,
        'non_compound_length_arg': non_compound_length_arg,
        'compound_length_arg': compound_length_arg,

        'for_loop': for_loop,

        'out_low_level_arg': out.get(data=False, ptr=True),
        'lhs_low_level_arg': lhs.get(data=False, ptr=True),
        'rhs_low_level_arg': rhs.get(data=False, ptr=True),

        'mesh_equality_assert': mesh_equality_assert,
        'compound_mesh_equality_assert': compound_mesh_equality_assert,

        'mesh_source': mesh_source,
        'non_compound_location_check': non_compound_location_check,
        'non_compound_location_set': non_compound_location_set,
        'compound_location_check': compound_location_check,

        'result_op': out.get(data=elementwise),
        'lhs_op': lhs.get(data=elementwise),
        'rhs_op': rhs.get(data=elementwise),
    }

    return template_args


if __name__ == "__main__":
    for_gcc = True
    print(header)

    for lhs, rhs in itertools.product(fields, fields):
        # We don't have define real real operations
        if lhs == rhs == 'BoutReal':
            continue
        rhs = copy(rhs)
        lhs = copy(lhs)

        # If both fields are the same, or one of them is real, we
        # don't need to care what element is stored where, but can
        # just loop directly over everything, using a simple c-style
        # for loop. Otherwise we need x,y,z of the fields.
        elementwise = lhs != rhs and lhs != 'BoutReal' and rhs != 'BoutReal'

        # The output of the operation. The `larger` of the two fields.
        out = returnType(rhs, lhs)
        out.name = 'result'
        lhs.name = 'lhs'
        rhs.name = 'rhs'

        for operator, operator_name in operators.items():
            template_args = conext_generator(operator, operator_name, out, lhs, rhs, elementwise)
            print(non_compound_template.format(**template_args))

            if out == lhs:
                print(compound_template.format(**template_args))
