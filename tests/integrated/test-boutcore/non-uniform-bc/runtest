#!/usr/bin/env python3
import boutcore as bc
import numpy as np
import sys

#requires boutcore
#requires not make

bc.init("-d data -q -q -q")

import matplotlib.pyplot as plt

def mget(f):
    return f[3,:,0].flatten()
mmax=10
start=2

def plot(*args):
    return None
    def close_event():
        plt.close()
    fig=plt.figure()
    for f in args:
        if "log" in f:
            f.remove("log")
            plt.loglog(*f)
        else:
            plt.plot(*f)
        #plt.plot(mget(y),mget(f),'-o')
        #plt.plot(mget(y),fo,'x-')
    timer = fig.canvas.new_timer(interval = 4000)
    timer.add_callback(close_event)
    timer.start()
    plt.show()
mesh_cache={}
y_cache={}
def test(bdry, func, loc):
    errs=[]
    dy=[]

    for ny in np.logspace(start,mmax,num=mmax-start+1,base=2):
        try:
            mesh=mesh_cache[ny]
            y=y_cache[ny]
        except KeyError:
            bc.setOption("mesh:ny","%d"%ny,force=True)
            bc.setOption("mesh:dy","(1+0.8*sin(y))/%d*2*pi"%ny,force=True)
            mesh=bc.Mesh(section="mesh")
            mesh_cache[ny]=mesh
            y=bc.create3D("realy",mesh,outloc=loc)
            y_cache[ny]=y
        f=func(y)
        fo=mget(f)
        y=mget(y)
        opt=bc.Options("")

        myg=int(opt.get("mesh:myg",0))

        for i in range(myg):
            f[0, i  ,0]=-1
            f[0,-1-i,0]=-1

        f.applyBoundary(bdry)
        f=mget(f)
        plot([y,f],[y,fo])
        #plot([y,f-fo])
        er=np.max(np.abs(f-fo))
        errs.append(er)
        dy.append(1./ny)

    #print(np.max(er))

    errc=np.log(errs[-2]/errs[-1])
    difc=np.log(dy[-2]/dy[-1])
    #print(dy)
    #print(errs)
    conv=errc/difc
    #print(conv)
    if order - .25 < conv < order + .25:
        return 0
    else:
        print("Failure: %s %s %s - expected %d, got %g"%(bdry,func,loc,order,conv))
        plot([dy,errs,"log"])
        return 1


testdata=[
    ["dirichlet_nu_o4", bc.sin, 5],
    ["dirichlet_nu_o3", bc.sin,3],
    ["dirichlet_nu_o2", bc.sin,3],
    ["neumann_nu_o2", bc.cos,2],
    ["neumann_nu_o3", bc.cos,5],
    ["neumann_nu_o4", bc.cos,4],
    ["free_nu_o2", bc.cos,2],
    ["free_nu_o3", bc.cos,4],
    ["free_nu_o4", bc.cos,4],
    ["free_nu_o2", bc.sin,3],
    ["free_nu_o3", bc.sin,3],
    ["free_nu_o4", bc.sin,5]
]
code=0
for bdry, func, order in testdata:
    for loc in ["CENTRE", "XLOW", "YLOW", "ZLOW"]:
        code += test(bdry, func, loc)

sys.exit(code)
