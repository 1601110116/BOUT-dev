#!/usr/bin/env python3
#
# Python script to run and analyse MMS test
#
from __future__ import division
from __future__ import print_function
from builtins import zip
from builtins import str

from boututils.run_wrapper import shell, launch, getmpirun
from boututils.datafile import DataFile
from boutdata.collect import collect

from numpy import sqrt, max, abs, mean, array, log, pi, polyfit, linspace

try:
    import matplotlib.pyplot as plt
except:
    pass

import pickle

from sys import stdout

import zoidberg as zb

nx = 5 # Not changed for these tests

# Resolution in y and z
nlist = [8,16,32,64,128,256]

nproc = 4

directory = "mms"

varlist = ["f", "g"]
markers = ['bo', 'r^']
labels = [r'$f$', r'$g$']

MPIRUN = getmpirun()

success=True

print("Making fci-slab test")
shell("make > make.log")

error_2 = {}
error_inf = {}
for var in varlist:
    error_2[var]   = []  # The L2 error (RMS)
    error_inf[var] = []  # The maximum error

for n in nlist:


    # Define the magnetic field using new poloidal gridding method
    field = zb.field.Slab(Bz=0.05, Bzprime=0.1)
    # Create rectangular poloidal grids
    poloidal_grid = zb.poloidal_grid.RectangularPoloidalGrid(nx,n,1.,1.)
    # Set the ylength and y locations
    ylength = 10.
    ycoords = linspace(0.0, ylength, n, endpoint=False)
    # Create the grid
    grid = zb.grid.Grid(poloidal_grid, ycoords, ylength, yperiodic=True)
    # Make and write maps
    maps = zb.make_maps(grid, field)
    zb.write_maps(grid, field, maps, new_names=False, metric2d=True)

    args = " -d "+directory+" MZ="+str(n)

    # Command to run
    cmd = "./fci_slab "+args

    # Launch using MPI
    s, out = launch(cmd, runcmd=MPIRUN, nproc=nproc, pipe=True)

    # Save output to log file
    with open("run.log."+str(n), "w") as f:
        f.write(out)

    for var in varlist:
        # Collect data
        E = collect("E_"+var, tind=[1,1], info=False, path=directory)
        E = E[:,2:-2, :,:]

        # Average error over domain
        l2 = sqrt(mean(E**2))
        linf = max(abs( E ))

        error_2[var].append( l2 )
        error_inf[var].append( linf )

        print("%s : l-2 %f l-inf %f" % (var, l2, linf))

dx = 1. / array(nlist)

# Save data
with open("fci_mms.pkl", "wb") as output:
    pickle.dump(nlist, output)
    pickle.dump(error_2, output)
    pickle.dump(error_inf, output)

# plot errors
try:
    plt.figure()
except:
    pass

# Calculate convergence order
for var,mark,label in zip(varlist, markers, labels):
    try:
        plt.plot(dx, error_2[var], '-'+mark, label=label)
        plt.plot(dx, error_inf[var], '--'+mark)
    except:
        pass

    fit = polyfit(log(dx), log(error_2[var]), 1)
    order = fit[0]
    stdout.write("%s Convergence order = %f" % (var, order))

    if order > 1.5: # Should be second order accurate
        print("............ PASS")
    else:
        print("............ FAIL")
        success = False

try:
    plt.legend(loc="upper left")
    plt.grid()

    plt.yscale('log')
    plt.xscale('log')

    plt.xlabel(r'Mesh spacing $\delta x$')
    plt.ylabel("Error norm")

    plt.savefig("fci-norm.pdf")

    plt.show()
    plt.close()
except:
    pass

if success:
    exit(0)
else:
    exit(1)
