#!/usr/bin/env python

# Python script to run and analyse MMS test
#
# Outputs PDF figures in each subdirectory
# Checks that the convergence is 2nd order
# Exits with status 1 if any test failed
 

from __future__ import division
from __future__ import print_function
from builtins import str

from boututils.run_wrapper import shell, launch, getmpirun
from boutdata.collect import collect

from numpy import sqrt, max, abs, mean, array, log, zeros

from os.path import join

MPIRUN = getmpirun()

def mkdir_p(path):
    import errno
    try:
        import os
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

print("Making MMS derivative test")
s,_ = shell("make > make.log")
if s:
    print("Make failed!")
    exit(1)

# List of input directories
inputs = [
    ("X", ["mesh:nx"]),
    ("Y",["mesh:ny"]),
    ("Z",["MZ"])#, 
    #("XYZ", ["mesh:nx", "mesh:ny", "MZ"])
    ]

funcs_periodic = {
    #'sin(x*fac)' : ['cos(x*fac)*fac','-sin(x*fac)*fac*fac'],
    '-sin(x*fac)*fac*cos(x*fac)' : ['cos(x*fac)', 'cos(x*fac)'],
    #'x*fac':'fac',
    #'fac':['1','x*fac'],
    '-fac*sin(x*fac)':['1','cos(x*fac)'],
    #'sin(x*fac)+sin(10*fac*x)' : ['fac*cos(fac*x)+fac*10*cos(10*fac*x)',
    #                              '-fac*fac*sin(fac*x)-fac*fac*100*sin(10*fac*x)'],
}

methods={
    "C2":2,
    "C4":4,
    "U1":1,
    "U2":2,
#    "U4":4,
}


facs={'X':'2*pi',
      'Y':'1',
      'Z':'1'    }

# List of NX values to use
nxlist = [16, 32, 64, 128, 256, 512]
#nxlist = [128,256,512,1024,2048,4096]

nout = 1
#timestep = 0.1
timestep = 0.1

nproc = 2

success = True
tmax=1
t_desc=[]
for i in [1]:
    t_desc.append("C->C d_%d"%i)
for i in [1]:
    t_desc.append("C->L d_%d"%i)
for i in [1]:
    t_desc.append("L->C d_%d"%i)
for i in [1]:
    t_desc.append("L->L d_%d"%i)

doPlot = 0 # 0, 1 or 2
if doPlot == 0:
    nxlist=nxlist[-2:] # just need behaviour in limit
for dir,sizes in inputs:
    print("Running test in '%s'" % (dir))
    for method,setOrder in methods.items():
        for diff,funs in funcs_periodic.items():
            error_2   = zeros((len(nxlist),tmax))  # The L2 error (RMS)
            error_inf = zeros((len(nxlist),tmax))  # The maximum error
            myindex=0
            for nx in nxlist:
                args = ""
                for s in sizes:
                    args += " "+s+"="+str(nx)
                args += " v:func="+funs[0].replace('x',dir)
                args += " f:func="+funs[1].replace('x',dir)
                args += " diff_"+dir+":function="+diff.replace('x',dir)
                args += " fac="+facs[dir]
                args += " mesh:dd%s:upwind=%s "%(dir,method)
                args = args.replace('(','\(').replace(')','\)')

                #print("  Running with " + args)

                # Delete old data
                shell("rm data/BOUT.dmp.*.nc")

                # Command to run
                cmd = "./test "+args
                print(cmd)
                # Launch using MPI
                s, out = launch(cmd, runcmd=MPIRUN, nproc=nproc, pipe=True)

                # Save output to log file
                fname="run.log."+str(nx)
                f = open(fname, "w")
                f.write(out)
                f.close()

                if s:
                    print("Run failed! Output written to %s."%fname)
                    print("Command was: %s"%cmd)
                    exit(2)
                # Collect data
                tr=[0,tmax-1]
                incGuards=False
                E_N = collect("error", path='data', tind=tr,info=False,xguards=incGuards,yguards=incGuards)


                # Average error over domain, not including guard cells
                for t in range(tmax):
                    l2   = sqrt(mean(E_N[t,:,:,:]**2))
                    linf = max(abs( E_N[t,:,:,:] ))
                    error_2[myindex,t]   = l2
                    error_inf[myindex,t] = linf
                myindex+=1
                #print("  -> Error norm: l-2 %f l-inf %f" % (l2, linf))
                if doPlot > 1:
                    N  = collect("diff"  , path='data', tind=tr,info=False,xguards=incGuards,yguards=incGuards)
                    N_ = collect("exact" , path='data', tind=tr,info=False,xguards=incGuards,yguards=incGuards)
                    try:
                        import matplotlib
                        matplotlib.use("pdf")
                        import matplotlib.pyplot as plt
                        plt.figure()
                        import numpy
                        dim=numpy.shape(E_N)
                        for i in range(dim[0]):
                            ix=1
                            iy=1
                            iz=1
                            if dir == 'X':
                                ix=dim[1]
                            elif dir == 'Y':
                                iy=dim[2]
                            elif dir == 'Z':
                                iz=dim[3]
                            else:
                                fuuu(We, shouldn,'t be here ...')
                            #plot error:
                            plt.plot( E_N[i,:ix,:iy,:iz].flatten(), '-o', label=r'$e: %s$'%t_desc[i])
                            #plot result:
                            #plt.plot( N  [i,:ix,:iy,:iz].flatten(), '-o', label=r'$d: %s$'%t_desc[i])
                            #plot expcected result:
                            #plt.plot( N_ [i,:ix,:iy,:iz].flatten(), '-o', label=r'$a_%d$'%i)
                        plt.legend(loc="upper left")
                        plt.grid()

                        plt.xlabel(r'Mesh spacing $%s$'%dir)
                        plt.ylabel("Error/Messurement")

                        fun=funs[0]+funs[1]
                        mkdir_p(join("data",dir,fun))
                        plt.savefig(join("data",dir,fun,"%d_%s.pdf"%(nx,method)))

                        #plt.show()
                        plt.close()
                    except KeyboardInterrupt:
                        raise
                    except:
                        print("plotting failed")
                        raise
                        pass

            # Calculate grid spacing
            #This is only correct in the x-direction if MXG = 1. In the other directions 
            #dy = 1/ny, dz = 1/(MZ-1)
            dx = 1. / (array(nxlist) - 2.)
            #print(error_inf)
            #print(error_2)
            # Calculate convergence order
            for t in range(tmax):
                order = log(error_2[-1,t] / error_2[-2,t]) / log(dx[-1] / dx[-2])

                print("Convergence order = %f" % (order))
                if not setOrder-.5 < order < setOrder+.5:
                    print(args, " - t=",t_desc[t])
                    print("=> FAILED\n")
                    success = False

                # plot errors
                if doPlot > 0:
                    try:
                        import matplotlib.pyplot as plt
                        plt.figure()
                        #print(numpy.shape(dx),numpy.shape(error_2))
                        plt.plot(dx, error_2[:,t], '-o', label=r'$l^2$')
                        plt.plot(dx, error_inf[:,t], '-x', label=r'$l^\infty$')

                        plt.plot(dx, error_2[-1,t]*(dx/dx[-1])**order, '--', label="Order %.1f"%(order))

                        plt.legend(loc="upper left")
                        plt.grid()

                        plt.yscale('log')
                        plt.xscale('log')

                        plt.xlabel(r'Mesh spacing $\delta x$')
                        plt.ylabel("Error norm")

                        mkdir_p(join("data",dir,fun))
                        plt.savefig(join("data",dir,fun,"%s_%s_norm.pdf"%(t_desc[t].replace(" ","_"),method)))

                        #plt.show()
                        plt.close()
                    except:
                        print("plotting failed")
                        pass

if success:
  print(" => All tests passed")
  exit(0)
else:
  print(" => Some failed tests")
  exit(1)
