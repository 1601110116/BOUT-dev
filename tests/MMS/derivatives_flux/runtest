#!/usr/bin/env python3

import boutcore
import numpy as np
import itertools

errorlist=""

boutcore.init("-d data -q -q -q".split(" "))

def runtests(functions,derivatives,directions,stag,msg):
    errorlist=''
    for vs,fs, anas in functions:
        for order,diff in derivatives:
            for direction,fac,guards, diff_func in directions:
                locations=['CENTRE']
                if stag:
                    locations.append(direction.upper()+"LOW")
                for locs in itertools.product(locations,locations):
                    errorlist+=runtest(nzs,guards,diff_func,diff,order,direction,fac,fs,vs,anas,locs,msg)
    return errorlist

def runtest(nzs,guards,diff_func,diff,order,direction,fac,fs,vs,anas,locs,msg):
    errors=[]
    for nz in nzs:
        boutcore.setOption("meshD:nD".replace("D",direction)
                           ,"%d"% (nz+ (2*guards if direction == "x" else 0)))
        boutcore.setOption("meshD:dD".replace("D",direction)
                           ,"2*pi/(%d)"%(nz))
        dirnfac=direction+"*"+fac
        mesh=boutcore.Mesh(OptionSection="mesh"+direction)
        v=boutcore.create3D(vs.replace("%s",dirnfac),mesh
                            ,outloc=locs[0])
        f=boutcore.create3D(fs.replace("%s",dirnfac)
                            ,mesh,outloc=locs[1])
        sim=diff_func(v,f,method=diff,outloc=locs[1])
        ana=boutcore.create3D(anas.replace("%s",dirnfac),mesh, outloc=locs[1])
        err=sim-ana
        err=err.getAll().flatten()
        if guards:
            err=err[guards:-guards]
        err=np.max(np.abs(err))
        errors.append(err)
    #return errors
    errc=np.log(errors[-2]/errors[-1])
    difc=np.log(nzs[-1]/nzs[-2])
    conv=errc/difc
    if order-.1 < conv < order+.1:
        #print("The convergence is: %f"%conv)
        fail=False
        error=""
    else:
        info="%s %s - %s - %s - %s %s -> %s "%(vs,fs,diff, direction,locs[0],locs[1],locs[1])
        error="%s: %s is not working. Expected %f got %f"%(msg,info,order,conv)
        print(error)
        fail=True
    if doPlot and fail:
        from matplotlib import pyplot as plt
        #plt.plot(1/np.array(nzs),errors,'-o')
        #plt.show()
        plt.plot((ana).getAll().flatten())
        plt.plot((sim).getAll().flatten())
        plt.show()
    return error


mmax=7
start=6
doPlot=False
nzs=np.logspace(start,mmax,num=mmax-start+1,base=2)

functions=[
    ["1","sin(%s)","cos(%s)"] ,
    ["sin(%s)" , "sin(%s)", "sin(2*%s)"]
]

derivatives=[
    [1,"U1"]
    , [2,"C2"] , [4,"C4"]
    # disable NND: expected convergence not tested
    #, [1, "NND"]
]

directions=[
    ["x","2*pi",2 ,boutcore.FDDX],
    ["y","1"   ,2 ,boutcore.FDDY],
    ["z","1"   ,0 ,boutcore.FDDZ]
]

runtests(functions,derivatives,directions,stag=False,msg="FDD")

derivatives=[[1,"U1"]]

runtests(functions,derivatives,directions,stag=True,msg="FDD")


functions=[
    ["1","sin(%s)","cos(%s)"],
    ["sin(%s)"  , "sin(%s)" , "sin(%s)*cos(%s)"]
]

derivatives=[[1,"U1"], [2,"U2"], [3,"U3"], [2,"C2"], [4,"C4"] ]

directions=[
    ["x","2*pi",2 ,boutcore.VDDX],
    ["y","1"   ,2 ,boutcore.VDDY],
    ["z","1"   ,0 ,boutcore.VDDZ]
]

runtests(functions,derivatives,directions,False,"VDD")

derivatives=[[1,"U1"], [2,"U2"], [2,"C2"], [4,"C4"] ]

runtests(functions,derivatives,directions,True,"VDD")



if errorlist != "":
    exit(1)
