#!/usr/bin/env python

# Python script to run and analyse MMS test
#
# Outputs PDF figures in each subdirectory
# Checks that the convergence is 2nd order
# Exits with status 1 if any test failed
 

from __future__ import division
from __future__ import print_function
from builtins import str

from boututils.run_wrapper import shell, launch, getmpirun
from boutdata.collect import collect

from numpy import sqrt, max, abs, mean, array, log, zeros

from os.path import join

MPIRUN = getmpirun()

def mkdir_p(path):
    import errno
    try:
        import os
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

print("Making MMS interpolation test")
shell("make > make.log")

# List of input directories
inputs = [
    ("X", ["mesh:nx"]),
    ("Y",["mesh:ny"]),
    ("Z",["MZ"])#, 
    #("XYZ", ["mesh:nx", "mesh:ny", "MZ"])
    ]

funcs_periodic = {
    'sin(x*fac)' : 'cos(x*fac)*fac',
    'cos(x*fac)' : '-sin(x*fac)*fac',
    'sin(x*fac)+sin(10*fac*x)' : 'fac*cos(fac*x)+fac*10*cos(10*fac*x)',
}

facs={'X':'2*pi',
      'Y':'1',
      'Z':'1'    }

shifts={'X': 2,
        'Y': 3,
        'Z': 4}

# List of NX values to use
nxlist = [8, 16, 32, 64, 128 , 256]#, 512]
#nxlist = [128,256,512,1024,2048,4096]

nout = 1
#timestep = 0.1
timestep = 0.1

nproc = 2

failed_list=[]
success_list=[]
success = True
tmax=1
setOrder = 4

doPlot = 0 # 1 -> conversionplot ; 2 -> also individual plots
if doPlot == 0:
    nxlist = nxlist[-2:]
for dir,sizes in inputs:
    print("Running test in '%s'" % (dir))
    for inloc in range(1,5):
      for outloc in range(1,5):
        expOrder=setOrder
        if inloc == outloc:
            continue
            expOrder=float("inf")
            pass
        if not shifts[dir] in [inloc,outloc]:
            #print("Skipping %d -> %d in %s MMS"%(inloc,outloc,dir))
            continue
            expOrder=float("inf")
            pass
        for fun,diff in funcs_periodic.iteritems():
            error_2   = zeros((len(nxlist),tmax))  # The L2 error (RMS)
            error_inf = zeros((len(nxlist),tmax))  # The maximum error
            myindex=0
            for nx in nxlist:
                args = ""
                for s in sizes:
                    args += " "+s+"="+str(nx)
                args += " all:function="+fun.replace('x',dir)
                args += " fac="+facs[dir]
                args += " inloc=%d outloc=%d"%(inloc,outloc)
                args = args.replace('(','\(').replace(')','\)')

                #print("  Running with " + args)

                # Delete old data
                shell("rm data/BOUT.dmp.*.nc")

                # Command to run
                cmd = "./test "+args
                # Launch using MPI
                s, out = launch(cmd, runcmd=MPIRUN, nproc=nproc, pipe=True)
                if s != 0:
                    print("Run crashed - aborting!")
                    exit(77)
                # Save output to log file
                f = open("run.log."+str(nx), "w")
                f.write(out)
                f.close()

                # Collect data
                tr=[0,tmax-1]
                incGuards=True
                E_N = collect("error", path='data', tind=tr,info=False,xguards=incGuards,yguards=incGuards)


                # Average error over domain, not including guard cells
                for t in range(tmax):
                    l2   = sqrt(mean(E_N[t,:,:,:]**2))
                    linf = max(abs( E_N[t,:,:,:] ))
                    error_2[myindex,t]   = l2
                    error_inf[myindex,t] = linf
                myindex+=1
                #print("  -> Error norm: l-2 %f l-inf %f" % (l2, linf))
                if doPlot > 1:
                    N  = collect("diff"  , path='data', tind=tr,info=False,xguards=incGuards,yguards=incGuards)
                    N_ = collect("exact" , path='data', tind=tr,info=False,xguards=incGuards,yguards=incGuards)
                    try:
                        import matplotlib.pyplot as plt
                        plt.figure()
                        import numpy
                        dim=numpy.shape(E_N)
                        for i in range(dim[0]):
                            ix=1
                            iy=1
                            iz=1
                            if dir == 'X':
                                ix=dim[1]
                            elif dir == 'Y':
                                iy=dim[2]
                            elif dir == 'Z':
                                iz=dim[3]
                            else:
                                fuuu(We, shouldn,'t be here ...')
                            #plot error:
                            plt.plot( E_N[i,:ix,:iy,:iz].flatten(), '-o', label=r'$e_%d$'%i)
                            #plot result:
                            plt.plot( N  [i,:ix,:iy,:iz].flatten(), '-o', label=r'$d_%d$'%i)
                            #plot expcected result:
                            plt.plot( N_ [i,:ix,:iy,:iz].flatten(), '-o', label=r'$a_%d$'%i)
                        plt.legend(loc="upper left")
                        plt.grid()

                        plt.xlabel(r'Mesh spacing $%s$'%dir)
                        plt.ylabel("Error/Messurement")

                        mkdir_p(join("data",dir,fun))
                        outf=join("data",dir,fun,"%d_%d_"%(inloc,outloc)+str(t)+"_%d.pdf"%nx)
                        print("save to %s"%outf)
                        plt.savefig(outf)

                        #plt.show()
                        plt.close()
                    except KeyboardInterrupt:
                        raise
                    except:
                        print("plotting failed")
                        raise
                        pass

            # Calculate grid spacing
            #This is only correct in the x-direction if MXG = 1. In the other directions 
            #dy = 1/ny, dz = 1/(MZ-1)
            dx = 1. / (array(nxlist) - 2.)
            #print(error_inf)
            #print(error_2)
            # Calculate convergence order
            for t in range(tmax):
                if error_2[-2,t] ==0:
                    order=float("inf")
                else:
                    order = log(error_2[-1,t] / error_2[-2,t]) / log(dx[-1] / dx[-2])
                
                if (not expOrder-.5 < order < expOrder+.5) and (not expOrder == order):
                    failed_list.append(args)
                    print("Convergence order = %f - FAILED (expected %.1f)" % (order,expOrder))
                    #print("=> FAILED\n")
                    success = False
                else:
                    success_list.append(args)
                    
                # plot errors
                if doPlot > 0:
                  try:
                    import matplotlib.pyplot as plt
                    plt.figure()
                    #print(numpy.shape(dx),numpy.shape(error_2))
                    plt.plot(dx, error_2[:,t], '-o', label=r'$l^2$')
                    plt.plot(dx, error_inf[:,t], '-x', label=r'$l^\infty$')
                    if order < 1e3:
                        plt.plot(dx, error_2[-1,t]*(dx/dx[-1])**order, '--', label="Order %.1f"%(order))

                    plt.legend(loc="upper left")
                    plt.grid()

                    plt.yscale('log')
                    plt.xscale('log')

                    plt.xlabel(r'Mesh spacing $\delta x$')
                    plt.ylabel("Error norm")

                    mkdir_p(join("data",dir,fun))
                    plt.savefig(join("data",dir,fun,"%d_%d_"%(inloc,outloc)+str(t)+"_norm.pdf"))

                    #plt.show()
                    plt.close()
                  except:
                    pass

if success:
    print(" => All tests passed")
    exit(0)
else:
    print(" => Some failed tests")
    print("Successfull:")
    for suc in success_list:
        print(suc)
    print("Failed:")
    for failed in failed_list:
        print(failed)
        
    exit(1)
