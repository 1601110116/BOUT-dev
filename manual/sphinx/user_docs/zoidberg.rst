.. _sec-zoidberg:

Zoidberg grid generator
=======================

The Zoidberg grid generator creates inputs for the Flux Coordinate Independent (FCI)
parallel transform (section :ref:`sec-parallel-transforms`). The domain is
divided into a set of 2D grids, and the magnetic field is followed from each
grid to where it either intersects the forward and backward grid, or hits a boundary.

Creating a grid consists of the following steps:

1. Define a magnetic field
2. Create the 2D "poloidal" grids
3. Create maps from each grid to its neighbours
4. Save grids to file

There are several examples in the `examples/zoidberg` directory
   
Magnetic fields
---------------

The magnetic field is represented by a ``MagneticField`` class, in ``zoidberg.field``.

Slabs and curved slabs
~~~~~~~~~~~~~~~~~~~~~~

The simplest magnetic field is a straight slab geometry:

.. code:: python

   import zoidberg
   field = zoidberg.field.Slab()

By default this has a magnetic field :math:`\mathbf{B} = \left(0, 1, 0.1 + x\right)`.    

A variant is a curved slab, which is defined in cylindrical coordinates
and has a given major radius (default 1):

.. code:: python

   import zoidberg
   field = zoidberg.field.CurvedSlab()

Note that this uses a large aspect-ratio approximation, so the major radius
is constant across the domain (independent of x). 
    
Straight stellarator
~~~~~~~~~~~~~~~~~~~~

This is generated by four coils with alternating currents arranged
on the edge of a circle, which spiral around the axis. 

This requires Sympy to generate the magnetic field, so if unavailable
an exception will be raised. 

.. code:: python
   
   import zoidberg
   field = zoidberg.StraightStellarator()



   

Plotting the magnetic field
---------------------------

Routines to plot the magnetic field are in ``zoidberg.plot``. 
To plot a Poincare plot, pass the ``MagneticField`` object,
start location(s) and periodicity information:

.. code:: python

   zoidberg.plot.plot_poincare(field, 0.1, 0.0, 1.0)

The inputs here are the starting location :math:`\left(x,z\right) = \left(0.1, 0.0\right)`,
and the periodicity in the y direction (1.0). By default this will
integrate from this given starting location 40 times (``revs`` option) around the y domain (0 to 1.0). 

An example generated by `this code <https://github.com/boutproject/BOUT-dev/blob/zoidberg-poloidal-grids/examples/zoidberg/poincare.py>`_ is shown in the poincare_ figure:

.. figure:: ../figs/zoidberg/poincare.png
   :name: poincare
   :alt: Points on four oval shaped flux surfaces in x-z at three locations along the y direction
   :scale: 50
   

   Poincare map of straight stellarator. Each colour corresponds to a different x-z plane
   in the y direction. Four flux surfaces are shown, each started at a point at :math:`y=0, z=0`.

   
         
Creating poloidal grids
-----------------------

The FCI technique is used for derivatives along the magnetic field
(in Y), and doesn't restrict the form of the grid in the X-Z
poloidal planes. A 3D grid created by Zoidberg is a collection of 2D planes
(poloidal grids), connected together by interpolations along
the magnetic field.To define a 3D grid we first need to define
the 2D poloidal grids.

Two types of poloidal grids can currently be created: Rectangular grids, and
curvilinear structured grids. All poloidal grids have the following
methods:

* `getCoordinate()` which returns the real space (R,Z) coordinates
  of a given (x,z) index, or derivatives thereof
* `findIndex()` which returns the (x,z) index of a given (R,Z) coordinate
  which in general is floating point
* `metric()` which returns the 2D metric tensor
* `plot()` which plots the grid

Rectangular grids
~~~~~~~~~~~~~~~~~

To create a rectangular grid, pass the number of points and lengths in the x and z directions
to ``RectangularPoloidalGrid``:

.. code:: python

   import zoidberg
   
   rect = zoidberg.poloidal_grid.RectangularPoloidalGrid( nx, nz, Lx, Lz )

By default the middle of the rectangle is at :math:`\left(R,Z\right) = \left(0,0\right)`
but this can be changed with the `Rcentre` and `Zcentre` options.



Curvilinear structured grids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `StructuredPoloidalGrid` class handles more general geometries,
but still assumes that the grid is logically rectangular.
Currently it also assumes that the z index is periodic,
i.e. an annulus.

One way to create this grid is to define the grid points manually e.g.:


.. code:: python
          
   import numpy as np
   import zoidberg
          
   r,theta = np.meshgrid(np.linspace(1,2,10),  # minor radius
                         np.linspace(0,2*np.pi, 10), # angle
                         indexing='ij')
   
   R = r * np.sin(theta)
   Z = r * np.cos(theta)

   grid = zoidberg.poloidal_grid.StructuredPoloidalGrid(R,Z)

   
For more complicated shapes than circles, it is better to use
a grid generator rather than try to manually specify the
grid point locations. Zoidberg comes with an elliptic grid
generator which needs to be given only the inner and outer 
boundaries.

.. code:: python

   import zoidberg

   inner = zoidberg.rzline.shaped_line(R0=3.0, a=0.5,
                            elong=1.0, triang=0.0, indent=1.0,
                            n=50)
   
   outer = zoidberg.rzline.shaped_line(R0=2.8, a=1.5,
                            elong=1.0, triang=0.0, indent=0.2,
                            n=50)
   
   grid = zoidberg.poloidal_grid.grid_elliptic(inner, outer, 100, 100, show=True)


which should produce the figure below:

.. figure:: ../figs/zoidberg/elliptic_grid.png
   :name: elliptic
   :alt: 
   :scale: 50
   
   A grid produced by ``grid_elliptic`` from shaped inner and outer lines
   
Here the ``shaped_line`` function creates RZline shapes with the following formula:

.. math::
   
   R = R_0 - b + \left(a + b \cos\left(\theta\right)\cos\left(\theta + \delta\sin\left(\theta\right)\right)\right)

   Z = \left(1 + \epsilon\right)a\sin\left(\theta\right)

where :math:`R_0` is the major radius, :math:`a` is the minor radius,
:math:`\epsilon` is the elongation (``elong``), :math:`\delta` the triangularity (``triang``), and :math:`b` the indentation (``indent``).

