#!/bin/bash
inc_dirs=
flags=
libs=
lib_dirs=
for fl in $(bout-config --cflags)
do
    if test ".${fl:0:2}" == ".-I"
    then
        inc_dirs+=" ${fl:2}"
    else
        flags+=" $fl"
    fi
done
for fl in $(bout-config --libs)
do
    s=${fl:0:2}
    if test ".$s" == ".-L"
    then
        lib_dirs+=" ${fl:2}"
    elif test ".$s" == ".-l"
    then
        libs+=" ${fl:2}"
    fi
done

cat <<EOF
# distutils: language = c++
# distutils: include_dirs = $inc_dirs
# distutils: libraries = $libs
# distutils: library_dirs = $lib_dirs
# distutils: sources = helper.cxx
# distutils: extra_compile_args = $flags

cimport boutcpp as c
import numpy as np
cimport numpy as np
import atexit
cimport resolve_enum as benum
from libc.stdlib cimport malloc, free

cdef extern from "helper.h":
     void c_set_f3d_all(c.Field3D * f3d, double * data)
     void c_get_f3d_all(c.Field3D * f3d, double * data)
     void c_get_f3d_part(c.Field3D * f3d, double * data,int xs,int xe, int dx,int ys,int ye, int dy,int zs,int ze, int dz)
     void c_set_f3d_part(c.Field3D * f3d, double * data,int xs,int xe, int dx,int ys,int ye, int dy,int zs,int ze, int dz)
     void c_set_f3d_part_(c.Field3D * f3d, double data,int xs,int xe, int dx,int ys,int ye, int dy,int zs,int ze, int dz)
     void c_set_f3d_all_(c.Field3D * f3d, double data)
EOF
for f in "add:+" "mul:*" "truediv:/" "div:/" "sub:-"
do
    n=${f%:*}
    echo "     c.Field3D * f$n( c.Field3D*, c.Field3D*)"
    echo "     c.Field3D * f$n( c.Field3D*, double)"
    echo "     c.Field3D * f$n( double, c.Field3D*)"
    echo "     void fi$n( c.Field3D*, c.Field3D*)"
    echo "     void fi$n( c.Field3D*, double)"
done
cat <<EOF
     c.Field3D c_minus( c.Field3D )
     c.Mesh * c_get_global_mesh()
     c.Field3D * c_ddz( c.Field3D * ,benum.CELL_LOC,benum.DIFF_METHOD,bool)
     void c_laplacian_solve(c.Laplacian *, c.Field3D *, c.Field3D*)
     c.Field3D c_Grad_perp_dot_Grad_perp(c.Field3D,c.Field3D);
     void c_mesh_normalise(c.Mesh* , double)
     
cdef Field3D f3dFromObj(c.Field3D i):
    f3d=Field3D()
    f3d.cobj=new c.Field3D(<const c.Field3D & ?>i)
    return f3d
cdef Field3D f3dFromPtr(c.Field3D * i):
    f3d=Field3D()
    f3d.cobj=i
    f3d.isSelfOwned=False
    return f3d
cdef class Field3D:
    """A wrapper for the Field3D"""
    cdef c.Field3D * cobj
    cdef c.bool isSelfOwned
    @classmethod
    def fromMesh(cls,mesh):
        fu=Field3D()
        fu.cobj=new c.Field3D((<Mesh?>mesh).cobj)
        return fu
    #@classmethod
    @classmethod
    def fromCollect(cls,name,tind=-1,mesh=None, **kwargs):
        """Create a Field3D from reading in a datafile via collect.
        Options:
            tind: time slice to read
            mesh: if not defined, use global mesh
        remaining arguments are passed to collect
        """
        from boutdata import collect
        data=collect(name,yguards=True,tind=tind,**kwargs)
        data=data.reshape(data.shape[1:])
        if len(data.shape) != 3:
            raise TypeError("expected 3d data")
        if mesh is None:
            mesh=Mesh.getGlobal()
        f3d=cls.fromMesh(mesh)
        f3d.setAll(data)
        return f3d
            
    def __cinit__(self,Field3D obj=None):
        self.cobj=NULL
        if obj:
            self.cobj=obj.cobj
        self.isSelfOwned=True
        #self.cobj = (<c.Field3D * ?> cobj_)
        #if self.cobj == NULL:
        #    raise MemoryError('Not enough memory, allocation failed.')

    def setAll(self,data):
        cdef np.ndarray[double, mode="c", ndim=3] data_ = np.ascontiguousarray(data)
        c_set_f3d_all(self.cobj,&data_[0,0,0]);
        #self.cobj.setData(0,0,0,data[0,0,0])

    def getAll(self):
        nx=self.cobj.getNx()
        ny=self.cobj.getNy()
        nz=self.cobj.getNz()
        #print(nx,ny,nz)
        cdef np.ndarray[double, mode="c", ndim=3] data_ = np.ascontiguousarray(np.zeros((nx,ny,nz)))
        c_get_f3d_all(self.cobj,&data_[0,0,0]);
        return data_
    def interp_to(self,location):
        cdef benum.CELL_LOC location_ = benum.resolve_cell_loc(location)
        return f3dFromObj(c.interp_to(self.cobj[0],location_))
    def setLocation(self,location):
        cdef benum.CELL_LOC location_ = benum.resolve_cell_loc(location)
        self.cobj[0].setLocation(location_)
        return self

    def ddt(self):
        return f3dFromPtr(&c.ddt(self.cobj[0]))

    def __neg__(self):
        return f3dFromObj(c_minus(self.cobj[0]))
    def isAllocated(self):
        return self.cobj.isAllocated()
    def __getitem__(self,slices):
        if len(slices)!=3:
            raise IndexError("This is a 3D object!")
        inds=resolve_slices(slices,
                            [self.cobj.getNx()
                             ,self.cobj.getNy()
                             ,self.cobj.getNz()])
        dims=[]
        for i in inds:
            dims.append((i[1]-i[0])//i[2])
        cdef np.ndarray[double, mode="c", ndim=3] data_ = np.ascontiguousarray(np.zeros(dims))
        c_get_f3d_part(self.cobj,&data_[0,0,0],inds[0][0],inds[0][1],inds[0][2],inds[1][0],inds[1][1],inds[1][2],inds[2][0],inds[2][1],inds[2][2]);
        return data_

    def set(self,data_):
        self.__setitem__([slice(None)]*3,data_)

    def __setitem__(self,slices,data_):
        if len(slices)!=3:
            raise IndexError("This is a 3D object!")
        inds=resolve_slices(slices,
                            [self.cobj.getNx()
                             ,self.cobj.getNy()
                             ,self.cobj.getNz()])
        dims=[]
        import numbers
        if isinstance(data_,Field3D):
            # get all to get a numpy array
            data_=data_[:,:,:]
        elif isinstance(data_,numbers.Number):
            c_set_f3d_part_(self.cobj,<double>data_,inds[0][0],inds[0][1],inds[0][2],inds[1][0],inds[1][1],inds[1][2],inds[2][0],inds[2][1],inds[2][2])
            return
        try:
            dims_in=data_.shape
        except:
            raise TypeError("Expected a Field3D or a numpy array")
        for i in inds:
            dims.append((i[1]-i[0])//i[2])
        if len(dims_in) != 3:
            raise IndexError()
        for i in range(3):
            if dims[i] != dims_in[i]:
                raise IndexError("Expected %s but got %s."%(dims,dims_in))
        cdef np.ndarray[double, mode="c", ndim=3] data__ = np.ascontiguousarray(data_)
        c_set_f3d_part(self.cobj,&data__[0,0,0],inds[0][0],inds[0][1],inds[0][2],inds[1][0],inds[1][1],inds[1][2],inds[2][0],inds[2][1],inds[2][2]);
EOF
for f in "add:+" "mul:*" "truediv:/" "div:/" "sub:-"
do
    n=${f%:*}
    #o=${f#*:}
    cat <<EOF
    def __${n}__(self,other):
        #print("call __${n}__")
        fu=Field3D()
        import numbers
        if isinstance(self,Field3D) and isinstance(other,Field3D):
            fu.cobj=f$n((<Field3D?>self).cobj , (<Field3D?>other).cobj)
        elif isinstance(self,Field3D) and isinstance(other, numbers.Number):
            fu.cobj=f$n((<Field3D?>self).cobj , (<double?>float(other)))
        elif isinstance(self,numbers.Number) and isinstance(other, Field3D):
            fu.cobj=f$n(<double?>float(self),(<Field3D?>other).cobj)
        else:
            print("$n",type(self),type(other),isinstance(self,numbers.Number))
            return NotImplemented
        return fu

    def __r${n}__(self,lhs):
        fu=Field3D()
        if isinstance(lhs,float) or isinstance(lhs,int):
            fu.cobj=f$n(<double?>float(lhs),(<Field3D?>self).cobj)
        else:
            raise NotImplemented("Unexpected lhs - not supported (yet?).")
        return fu

    def __i${n}__(self,other):
        if isinstance(other,Field3D):
            fi$n((<Field3D?>self).cobj , (<Field3D?>other).cobj)
        elif isinstance(other,float) or isinstance(other,int):
            fi$n((<Field3D?>self).cobj , (<double?>float(other)))
        else:
            raise NotImplemented("Unexpected lhs - not supported (yet?).")
        return self

EOF
    
done
cat <<EOF
    def __dealloc__(self):
        if self.isSelfOwned and self.cobj!=NULL:
            del self.cobj
            self.cobj=NULL
        
cdef class Mesh:
    cdef c.Mesh * cobj;
    cdef c.bool isGlobal
    cdef double isNormalised
    cdef FieldFactory factory
    #factory=FieldFactory()
    def __init__(self, create=True,OptionSection=None):
        self.cobj=<c.Mesh*>0
        cdef c.string tmp
        cdef c.Options * opt
        self.isGlobal=False
        self.isNormalised=-1
        self.factory = FieldFactory()
        if create:
            if OptionSection:
                opt = c.Options.getRoot()
                for sec in OptionSection.split(":"):
                    tmp=sec.encode('ascii')
                    opt=opt.getSection(tmp)
                self.cobj=c.Mesh.create(opt)
            else:
                self.cobj = c.Mesh.create(<c.Options *>0)
            if self.cobj == NULL:
                raise MemoryError('Not enough memory, allocation failed.')
            self.cobj.load()
            self.cobj.setParallelTransform()

    @classmethod
    def getGlobal(cls):
        msh = Mesh(create=False);
        msh.cobj = c_get_global_mesh();
        msh.isGlobal=True
        return msh

    def __dealloc__(self):
        if self.cobj and not self.isGlobal:
            del self.cobj

    cdef getFactory(self):
        if (<FieldFactory>self.factory).cobj == <c.FieldFactory*>0:
            (<FieldFactory?>self.factory).cobj = new c.FieldFactory(self.cobj,<c.Options*>0)
        return self.factory
    def normalise(self,double norm):
        if self.isNormalised>0:
            t=norm
            norm=norm/self.isNormalised
            self.isNormalised=t
        c_mesh_normalise(self.cobj,norm)
    def communicate(self,*args):
        cdef c.FieldGroup * fg = new c.FieldGroup()
        for f in args:
            fg.add((<Field3D?> f).cobj[0])
        self.cobj.communicate(fg[0])
        del fg
        return self

cdef class Laplacian:
    cdef c.Laplacian * cobj
    def __init__(self,section=None):
        if section:
           self.cobj = c.Laplacian.create((<Options?>section).cobj)
        else:
           self.cobj = c.Laplacian.create(NULL)
        
    def solve(self,Field3D a, Field3D b):
        return f3dFromObj(self.cobj.solve(a.cobj[0],b.cobj[0]))

cdef class FieldFactory:
    cdef c.FieldFactory * cobj
    def __init__(self):
        cobj=< c.FieldFactory*>0
    def __dealloc__(self):
        if self.cobj != <c.FieldFactory*>0:
            del self.cobj
    # @classmethod
    # def fromPtr(cls,FieldFactory * cobj_):
    #     fu=cls()
    #     fu.cobj=cobj_
    #     return fu

cdef void callback(void * parameter, void * method):
     cdef double time = (<double*>parameter)[0]
     (<object?>method)(time)

ctypedef void (*Method)(void *param)
#, void *user_data)

cdef class PythonModelCallback:
    cdef c.PythonModelCallback * cobj

    def __cinit__(self, method):
        # 'callback' :: The pattern/converter method to fire a Python 
        #               object method from C typed infos
        # 'method'   :: The effective method passed by the Python user 
       self.cobj = new c.PythonModelCallback(callback, <void*>method)

    def __dealloc__(self):
       if self.thisptr:
           del self.thisptr

    cpdef void execute(self, parameter):
        # 'parameter' :: The parameter to be passed to the 'method'
        self.cobj.cy_execute(<void*>parameter)

cdef class PhysicsModel:
    cdef c.PythonModel * cmodel
    cdef c.PythonModelCallback * callback
    def __init__(self):
        self.cmodel  = new c.PythonModel()
        self.cmodel.pyinit()
        self.callback= <c.PythonModelCallback*> 0

    def solve(self):
        self.cmodel.solve()
        #self.cmodel.getSolver().solve()

    def solve_for(self,**kwargs):
        cdef char * tmp
        cdef c.Field3D * f3d
        for key in kwargs:
            t2=str.encode(key)
            tmp=t2
            f3d=(<Field3D?>kwargs[key]).cobj
            self.cmodel.getSolver().add(f3d[0],tmp)

    def setRhs(self,rhs):
        if self.callback != <c.PythonModelCallback*>0:
           del self.callback
        self.callback = new c.PythonModelCallback(callback, <void*> rhs)
        self.cmodel.set_rhs_func(self.callback)

    def __dealloc__(self):
        self.cmodel.free()
        del self.cmodel
        del self.callback

cdef extern from "bout.hxx":
    int BoutInitialise(int&, char **&)
    void BoutFinalise()
    
isInit=False
def init(args):
    args.insert(0,"boutcore")
    cdef char **string_buf = <char **>malloc(len(args) * sizeof(char*))
    fu=[]
    cdef char * tmp
    for i in range(len(args)):
        t2=str.encode(args[i])
        tmp=t2
        fu.append(tmp)
        string_buf[i]=<char*>fu[i]
    cdef int fuu=len(args)
    ret=BoutInitialise(fuu,string_buf)
    free(string_buf)
    if ret:
        BoutFinalise()
    else:
        isInit=True
    #atexit.register(finalise)

def finalise():
    BoutFinalise()
    isInit=False

def DDZ(Field3D field, outloc="CELL_DEFAULT", method="DIFF_DEFAULT", inc_xbndry=True):
    cdef benum.CELL_LOC outloc_= benum.resolve_cell_loc(outloc)
    cdef benum.DIFF_METHOD method_=benum.resolve_diff_method(method)
    return f3dFromObj(c.DDZ(field.cobj[0],outloc_,method_,inc_xbndry))

def Vpar_Grad_par(Field3D V, Field3D f, outloc="CELL_DEFAULT",method="DIFF_DEFAULT"):
    cdef benum.CELL_LOC outloc_= benum.resolve_cell_loc(outloc)
    cdef benum.DIFF_METHOD method_=benum.resolve_diff_method(method)
    return f3dFromObj(c.Vpar_Grad_par(V.cobj[0],f.cobj[0],outloc_,method_))

def Div_par(Field3D J, outloc="CELL_DEFAULT",method="DIFF_DEFAULT"):
    cdef benum.CELL_LOC outloc_=benum.resolve_cell_loc(outloc)
    cdef benum.DIFF_METHOD method_=benum.resolve_diff_method(method)
    return f3dFromObj(c.Div_par((J.cobj)[0],outloc_,method_))

def Grad_par(Field3D J, outloc="CELL_DEFAULT",method="DIFF_DEFAULT"):
    cdef benum.CELL_LOC outloc_=benum.resolve_cell_loc(outloc)
    cdef benum.DIFF_METHOD method_=benum.resolve_diff_method(method)
    return f3dFromObj(c.Grad_par((J.cobj)[0],outloc_,method_))

def bracket(Field3D a, Field3D b, method="BRACKET_STD", outloc="CELL_DEFAULT"):
    cdef benum.CELL_LOC outloc_=benum.resolve_cell_loc(outloc)
    cdef benum.BRACKET_METHOD method_=benum.resolve_bracket_method(method)
    return f3dFromObj(c.bracket(a.cobj[0],b.cobj[0],method_,outloc_))

def sqrt(Field3D a):
    return f3dFromObj(c.sqrt(a.cobj[0]))

def exp(Field3D a):
    return f3dFromObj(c.exp(a.cobj[0]))

def Delp2(Field3D a, zsmooth=-1):
    return f3dFromObj(c.Delp2(a.cobj[0],float(zsmooth)))

def Grad_perp_dot_Grad_perp(Field3D a, Field3D b):
    return f3dFromObj(c_Grad_perp_dot_Grad_perp(a.cobj[0],b.cobj[0]))

def create3D(string, Mesh msh,outloc="CELL_DEFAULT",time=0):
    cdef benum.CELL_LOC outloc_=benum.resolve_cell_loc(outloc)
    cdef FieldFactory fact=msh.getFactory()
    cdef c.string str_=string.encode('ascii')
    #cdef char * func=string_
    return f3dFromObj(
        (<FieldFactory>fact).cobj.create3D(str_,<c.Options*>0,<c.Mesh*>0
                                           ,outloc_,time))

def setOption(name, value):
    cdef c.Options * opt = c.Options.getRoot()
    cdef c.string sec_
    for sec in name.split(":")[:-1]:
        sec_=sec.encode('ascii')
        opt=opt.getSection(sec_)
    cdef c.string key = name.split(":")[-1].encode('ascii')
    cdef c.string value_ = value.encode('ascii')
    cdef c.string source = "PyInterface".encode('ascii')
    opt.set(key,value_, source)

EOF

cat helper.py
