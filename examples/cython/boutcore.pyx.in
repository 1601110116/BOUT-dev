#!/bin/bash
inc_dirs=
flags=
libs=
lib_dirs=
for fl in $(bout-config --cflags)
do
    if test ".${fl:0:2}" == ".-I"
    then
        inc_dirs+=" ${fl:2}"
    else
        flags+=" $fl"
    fi
done
for fl in $(bout-config --libs)
do
    s=${fl:0:2}
    if test ".$s" == ".-L"
    then
        lib_dirs+=" ${fl:2}"
    elif test ".$s" == ".-l"
    then
        libs+=" ${fl:2}"
    fi
done

cat <<EOF
# distutils: language = c++
# distutils: include_dirs = $inc_dirs
# distutils: libraries = $libs
# distutils: library_dirs = $lib_dirs
# distutils: sources = helper.cxx
# distutils: extra_compile_args = $flags

cimport boutcpp as c
print "hello World"
import numpy as np
cimport numpy as np
import atexit
cimport resolve_enum as benum
from libc.stdlib cimport malloc, free

cdef extern from "helper.h":
     void c_set_f3d_all(c.Field3D * f3d, double * data)
     void c_get_f3d_all(c.Field3D * f3d, double * data)
EOF
for f in "add:+" "mul:*" "div:/" "sub:-"
do
    n=${f%:*}
    echo "     c.Field3D * f$n( c.Field3D*,c.Field3D*)"
done
cat <<EOF
     c.Mesh * c_get_global_mesh()
     c.Field3D * c_ddz( c.Field3D * ,benum.CELL_LOC,benum.DIFF_METHOD,bool)

# cdef extern from "bout_types.hxx":
#     cdef enum CELL_LOC:
#         CELL_DEFAULT,
#         CELL_CENTRE,
#         CELL_CENTER,
#         CELL_XLOW,
#         CELL_YLOW,
#         CELL_ZLOW,
#         CELL_VSHIFT

# cdef inline CELL_LOC  resolve_cell_loc (str):
#     opts={
#         "CELL_DEFAULT":CELL_DEFAULT,
#         "CELL_CENTRE":CELL_CENTRE,
#         "CELL_CENTER":CELL_CENTER,
#         "CELL_XLOW":CELL_XLOW,
#         "CELL_YLOW":CELL_YLOW,
#         "CELL_ZLOW":CELL_ZLOW,
#         "CELL_VSHIFT":CELL_VSHIFT,
#           }
#     return opts[str]

EOF
#cat resolve_enum.pxd
cat <<EOF


cdef class Field3D:
    """A wrapper for the Field3D"""
    cdef c.Field3D * cobj
    @classmethod
    def fromMesh(cls,mesh):
        fu=Field3D()
        fu.cobj=new c.Field3D((<Mesh?>mesh).cobj)
        return fu
    
    def __cinit__(self,Field3D obj=None):
        self.cobj=NULL
        if obj:
            self.cobj=obj.cobj
        #self.cobj = (<c.Field3D * ?> cobj_)
        #if self.cobj == NULL:
        #    raise MemoryError('Not enough memory, allocation failed.')

    def setAll(self,data):
        cdef np.ndarray[double, mode="c", ndim=3] data_ = np.ascontiguousarray(data)
        c_set_f3d_all(self.cobj,&data_[0,0,0]);
        #self.cobj.setData(0,0,0,data[0,0,0])

    def getAll(self):
        nx=c.getNx(self.cobj)
        ny=c.getNy(self.cobj)
        nz=c.getNz(self.cobj)
        print(nx,ny,nz)
        cdef np.ndarray[double, mode="c", ndim=3] data_ = np.ascontiguousarray(np.zeros((nx,ny,nz)))
        c_get_f3d_all(self.cobj,&data_[0,0,0]);
        return data_
EOF
for f in "add:+" "mul:*" "div:/" "sub:-"
do
    n=${f%:*}
    #o=${f#*:}
    echo "
    def __${n}__(self,other):
        fu=Field3D()
        fu.cobj=f$n((<Field3D?>self).cobj , (<Field3D?>other).cobj)
        return fu"
    # def __mul__(self,other):
    #     fu=Field3D()
    #     fu.cobj=fmul((<Field3D?>self).cobj , (<Field3D?>other).cobj)
    #     return fu
done
cat <<EOF
    def __del__(self):
        del self.cobj
        
cdef class Mesh:
    cdef c.Mesh * cobj;
    def __init__(self, create=True):
        if create:
            self.cobj = c.Mesh.create()
            if self.cobj == NULL:
                raise MemoryError('Not enough memory, allocation failed.')
            self.cobj.load()
            self.cobj.setParallelTransform()
            self.cobj.load()
            self.cobj.setParallelTransform()
    @classmethod
    def getGlobal(cls):
        msh = Mesh(create=False);
        msh.cobj = c_get_global_mesh();
        return msh

cdef extern from "bout.hxx":
    int BoutInitialise(int&, char **&)
    void BoutFinalise()
    
isInit=False
def init(args):
    cdef char **string_buf = <char **>malloc(len(args) * sizeof(char*))
    fu=[]
    cdef char * tmp
    for i in range(len(args)):
        tmp=args[i]
        fu.append(tmp)
        string_buf[i]=<char*>fu[i]
    cdef int fuu=len(args)
    ret=BoutInitialise(fuu,string_buf)
    free(string_buf)
    if ret:
        BoutFinalise()
    else:
        isInit=True
    atexit.register(finalise)

def finalise():
    BoutFinalise()
    isInit=False

def DDZ(field, outloc="CELL_DEFAULT", method="DIFF_DEFAULT", inc_xbndry=True):
    ret=Field3D()
    cdef benum.CELL_LOC outloc_= benum.resolve_cell_loc(outloc)
    cdef benum.DIFF_METHOD method_=benum.resolve_diff_method(method)
    ret.cobj = c_ddz((<Field3D?>field).cobj,outloc_,method_,inc_xbndry)
    
EOF

#cat resolve_enum.pxd
